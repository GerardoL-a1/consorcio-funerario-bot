# -*- coding: utf-8 -*-
from flask import Flask, request
import sys
import io
import requests
import os
import threading
import logging
from twilio.twiml.messaging_response import MessagingResponse
from planes_info import responder_plan
from difflib import SequenceMatcher  # para comparar palabras similares

sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
TWILIO_MESSAGING_URL = f"https://api.twilio.com/2010-04-01/Accounts/{TWILIO_ACCOUNT_SID}/Messages.json"
TWILIO_AUTH = (TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
NUMERO_REENVIO = "+525523604519"

sesiones = {}
temporizadores = {}

@app.route("/", methods=["GET"])
def home():
    return "‚úÖ Bot Consorcio Funerario funcionando."

MENSAJE_BIENVENIDA = """üëã *Bienvenido a Consorcio Funerario*

Gracias por escribirnos.

Por favor ind√≠quenos *en qu√© le gustar√≠a recibir informaci√≥n o en qu√© podemos apoyarle*:
- Atenci√≥n inmediata por *emergencia*
- Conocer nuestros *servicios funerarios*
- Consultar nuestras *ubicaciones disponibles*

üìå Puede escribir palabras como: *emergencia*, *planes*, *servicios*, *ubicaci√≥n*, etc."""
# --------------------------------------------- #
# PALABRAS CLAVE GENERALES
# --------------------------------------------- #

claves_planes = ["plan", "planes", "servicio", "servicios", "paquete", "informaci√≥n", "informacion"]
claves_emergencia = [
   "emergencia", "urgente", "fallecido", "muri√≥", "murio", "accidente", "suceso",
    "acaba de fallecer", "acaba de morir", "necesito ayuda con un funeral", "necesito apoyo",
    "ay√∫denos", "urgente apoyo", "urgente funeral", "funeral urgente", "ayuda urgente",
    "se muri√≥", "se nos fue", "ya no est√°", "ya falleci√≥", "ya muri√≥",
    
    # Familiares directos
    "muri√≥ mi pap√°", "falleci√≥ mi pap√°", "mi pap√° muri√≥", "mi pap√° falleci√≥",
    "muri√≥ mi mam√°", "falleci√≥ mi mam√°", "mi mam√° muri√≥", "mi mam√° falleci√≥",
    "muri√≥ mi hijo", "falleci√≥ mi hijo", "mi hijo muri√≥", "mi hijo falleci√≥",
    "muri√≥ mi hija", "falleci√≥ mi hija", "mi hija muri√≥", "mi hija falleci√≥",

    # Familiares indirectos y otras relaciones
    "muri√≥ mi abuelo", "falleci√≥ mi abuelo", "muri√≥ mi abuela", "falleci√≥ mi abuela",
    "muri√≥ mi t√≠o", "falleci√≥ mi t√≠o", "muri√≥ mi t√≠a", "falleci√≥ mi t√≠a",
    "muri√≥ mi primo", "falleci√≥ mi primo", "muri√≥ mi prima", "falleci√≥ mi prima",
    "muri√≥ mi suegro", "falleci√≥ mi suegro", "muri√≥ mi suegra", "falleci√≥ mi suegra",
    "muri√≥ mi padrastro", "falleci√≥ mi padrastro", "muri√≥ mi madrastra", "falleci√≥ mi madrastra",
    "muri√≥ mi cu√±ado", "falleci√≥ mi cu√±ado", "muri√≥ mi cu√±ada", "falleci√≥ mi cu√±ada",

    # Frases informales y m√°s coloquiales
    "muri√≥ alguien", "falleci√≥ alguien", "alguien acaba de morir", "se muri√≥ un familiar",
    "se nos fue un ser querido", "perdimos a un familiar", "perd√≠ a un ser querido",
    "acaba de fallecer un familiar", "mi familiar muri√≥", "mi ser querido falleci√≥",
    "necesito un servicio funerario urgente", "necesito apoyo urgente", "urgente atenci√≥n",
    "urgencia funeraria", "urgente fallecimiento", "atenci√≥n por fallecimiento"
]
claves_ubicacion = ["ubicaci√≥n", "ubicaciones", "sucursal", "sucursales", "direcci√≥n", "direccion"]
claves_cierre = ["gracias", "ok", "vale", "de acuerdo", "listo", "perfecto", "entendido", "muy bien"]

# Diccionario de letras -> servicio (Aseguramos que las claves sean may√∫sculas para una comparaci√≥n consistente)
selecciones_letras = {
    **{k: "cr√©dito de necesidad inmediata" for k in ["A", "a"]},
    **{k: "servicio paquete fetal cremaci√≥n" for k in ["B", "b"]},
    **{k: "servicio paquete sencillo sepultura" for k in ["C", "c"]},
    **{k: "servicio paquete b√°sico sepultura" for k in ["D", "d"]},
    **{k: "servicio cremaci√≥n directa" for k in ["E", "e"]},
    **{k: "servicio paquete de cremaci√≥n" for k in ["F", "f"]},
    **{k: "servicio paquete legal" for k in ["G", "g"]},
    **{k: "servicio de refrigeraci√≥n y conservaci√≥n" for k in ["H", "h"]},
    **{k: "red biker" for k in ["I", "i"]},
    **{k: "red plus" for k in ["J", "j"]},
    **{k: "red consorcio" for k in ["K", "k"]},
    **{k: "red adulto mayor" for k in ["L", "l"]},
    **{k: "preventa de nichos a temporalidad" for k in ["M", "m"]},
    **{k: "traslado" for k in ["N", "n"]},
    **{k: "ata√∫d" for k in ["O", "o"]},
    **{k: "urna" for k in ["P", "p"]},
    **{k: "velaci√≥n" for k in ["Q", "q"]},
    **{k: "boletas" for k in ["R", "r"]},
    **{k: "carroza local" for k in ["S", "s"]},
    **{k: "carroza a pante√≥n u horno crematorio" for k in ["T", "t"]},
    **{k: "carroza legal" for k in ["U", "u"]},
    **{k: "cami√≥n local" for k in ["V", "v"]},
    **{k: "embalsamado" for k in ["W", "w"]},
    **{k: "embalsamado legal" for k in ["X", "x"]},
    **{k: "embalsamado infecto-contagiosa" for k in ["Y", "y"]},
    **{k: "tr√°mites de inhumaci√≥n" for k in ["Z", "z"]},
    **{k: "tr√°mites de cremaci√≥n" for k in ["AA", "aa", "Aa", "aA"]},
    **{k: "tr√°mites legales" for k in ["AB", "ab", "Ab", "aB"]},
    **{k: "tr√°mites de traslado" for k in ["AC", "ac", "Ac", "aC"]},
    **{k: "tr√°mites de internaci√≥n nacional" for k in ["AD", "ad", "Ad", "aD"]},
    **{k: "tr√°mites de internaci√≥n internacional" for k in ["AE", "ae", "Ae", "aE"]},
    **{k: "equipo de velaci√≥n" for k in ["AF", "af", "Af", "aF"]},
    **{k: "cirios" for k in ["AG", "ag", "Ag", "aG"]},
    **{k: "capilla de gobierno" for k in ["AH", "ah", "Ah", "aH"]},
    **{k: "capilla particular" for k in ["AI", "ai", "Ai", "aI"]},
    **{k: "traslado carretero por km" for k in ["AJ", "aj", "Aj", "aJ"]},
    **{k: "traslado de terracer√≠a por km" for k in ["AK", "ak", "Ak", "aK"]},
    **{k: "cami√≥n for√°neo por km" for k in ["AL", "al", "Al", "aL"]},
}

# --------------------------------------------- #
# FUNCIONES AUXILIARES
# --------------------------------------------- #

def contiene(palabras, mensaje):
    return any(p in mensaje.lower() for p in palabras)

def responder(texto):
    respuesta = MessagingResponse()
    respuesta.message(texto)
    return str(respuesta)

def mensaje_inactividad(numero):
    if numero in sesiones:
        requests.post(TWILIO_MESSAGING_URL, auth=TWILIO_AUTH, data={
            "To": numero,
            "From": "whatsapp:+14155238886",
            "Body": "‚åõ ¬øA√∫n est√°s ah√≠? Si necesitas ayuda, escribe la palabra *men√∫* para volver al inicio."
        })
        temporizadores.pop(numero, None)

# --------------------------------------------- #
# DETECCI√ìN INTELIGENTE DE PALABRAS SIMILARES
# --------------------------------------------- #

def parecido(palabra_objetivo, mensaje, umbral=0.75):
    """Detecta si una palabra es suficientemente parecida al mensaje recibido."""
    return SequenceMatcher(None, palabra_objetivo.lower(), mensaje.lower()).ratio() >= umbral
    
def contiene_flexible(lista_claves, mensaje_usuario, umbral=0.75):
    """Devuelve True si el mensaje es similar a alguna palabra clave."""
    mensaje_usuario = mensaje_usuario.strip().lower()
    for palabra_clave in lista_claves:
        if parecido(palabra_clave, mensaje_usuario, umbral):
            return True
    return False

def es_mensaje_menu(mensaje):
    return (
        mensaje.strip().lower() in ["men√∫", "menu", "men√π", "inicio", "menuh", "inicioo", "home"]
        or parecido("men√∫", mensaje)
        or parecido("menu", mensaje)
    )

def es_mensaje_regresar(mensaje):
    return (
        mensaje.strip().lower() in ["regresar", "volver", "regresa", "regreso"]
        or parecido("regresar", mensaje)
        or parecido("volver", mensaje)
    )

@app.route("/webhook", methods=["POST"])
def webhook():
    mensaje = request.form.get("Body", "").strip()
    telefono = request.form.get("From", "")
    logging.info(f"Mensaje recibido: {mensaje} de {telefono}")

    if not mensaje:
        return responder("‚ùó No recibimos texto. Por favor escribe tu mensaje.")

    # --- Reiniciar temporizador de inactividad por cada mensaje recibido ---
    if telefono in temporizadores:
        temporizadores[telefono].cancel()
        del temporizadores[telefono]
    temporizador = threading.Timer(600, mensaje_inactividad, args=(telefono,))
    temporizador.start()
    temporizadores[telefono] = temporizador

    # --- Volver al men√∫ principal si se detecta 'men√∫' con tolerancia (PRIORIDAD ALTA) ---
    if es_mensaje_menu(mensaje):
        # Reinicia completamente la sesi√≥n para asegurar que el usuario vuelve al inicio
        sesiones[telefono] = {}
        return responder(MENSAJE_BIENVENIDA)

    # --- Regresar a submen√∫s si se detecta 'regresar' ---
    if es_mensaje_regresar(mensaje):
        if "submenu" in sesiones.get(telefono, {}):
            if sesiones[telefono]["menu"] == "planes":
                # Elimina el submenu para volver a la selecci√≥n 1, 2, 3 de planes
                del sesiones[telefono]["submenu"]
                # Si estaba en servicios individuales, tambi√©n reinicia menu_serv
                if "menu_serv" in sesiones[telefono]:
                    del sesiones[telefono]["menu_serv"]
                return responder("üîô Has regresado al submen√∫ de *planes*. Escribe 1, 2 o 3 para seleccionar otra opci√≥n.\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")
            elif sesiones[telefono]["menu"] == "ubicacion":
                # En ubicaci√≥n, "regresar" deber√≠a llevar a la pregunta de cita si ya se mostr√≥ la lista
                # Si ya se pregunt√≥ por cita, volver a preguntar
                if sesiones[telefono].get("menu") == "cita": # Si estaba en el flujo de cita, regresa a la pregunta de ubicacion
                    sesiones[telefono]["menu"] = "ubicacion"
                    return responder("üîô Has regresado al submen√∫ de *ubicaciones*. ¬øDeseas agendar una cita? Responde 's√≠' o 'no'.\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")
                else: # Si no estaba en cita, pero en ubicacion, no hay un "sub-submen√∫" al que regresar
                    return responder("üîô No hay men√∫ anterior al cual regresar en *ubicaciones*. ¬øDeseas agendar una cita? Responde 's√≠' o 'no'.\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")
        elif "menu_serv" in sesiones.get(telefono, {}):
            # Si est√° en un sub-submen√∫ de servicios individuales (tr√°mites, traslados, etc.)
            if sesiones[telefono]["menu_serv"] != "categorias": # Si no est√° ya en la vista de categor√≠as
                sesiones[telefono]["menu_serv"] = "categorias"
                return responder("üîô Has regresado a la categor√≠a de *servicios individuales*. Elige A, B, C o D.\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")
            else: # Si ya est√° en categor√≠as, regresar deber√≠a llevar al men√∫ principal de planes
                del sesiones[telefono]["submenu"]
                del sesiones[telefono]["menu_serv"]
                return responder("üîô Has regresado al submen√∫ de *planes*. Escribe 1, 2 o 3 para seleccionar otra opci√≥n.\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")
        else:
            return responder("üîô No hay men√∫ anterior al cual regresar. Puedes escribir la palabra *men√∫* para volver al inicio.")

    # --- Confirmaciones como "gracias", "ok", etc. ---
    if contiene(claves_cierre, mensaje):
        return responder("üëå Gracias por confirmar. Si necesitas algo m√°s, escribe la palabra *men√∫* para volver al inicio.")
    
    # ----------------------------- #
    # FLUJO: BIENVENIDA Y DETECCI√ìN INICIAL
    # ----------------------------- #
    # Si no hay sesi√≥n activa, o si la sesi√≥n se reinici√≥ (por "men√∫")
    if not sesiones.get(telefono):
        if contiene(claves_emergencia, mensaje):
            sesiones[telefono] = {"menu": "emergencia"}
            return responder("""üö® *ATENCI√ìN INMEDIATA*

Por favor responde con los siguientes datos:
üîπ Nombre completo del fallecido
üîπ Suceso o causa del fallecimiento
üîπ Ubicaci√≥n actual del cuerpo
üîπ ¬øYa cuenta con su certificado de defunci√≥n?
üîπ Dos n√∫meros de contacto
üîπ Nombre de la persona que nos est√° contactando

üìå Si fue un error, escribe la palabra *men√∫* para regresar al inicio.""")

        elif contiene(claves_ubicacion, mensaje):
            sesiones[telefono] = {"menu": "ubicacion"}
            return responder("""üìç *Ubicaciones disponibles:*
1. Av. Tl√°huac No. 5502, Col. El Rosario, CDMX
2. Av. Zacatl√°n No. 60, Col. San Lorenzo Tezonco, CDMX
3. Av. Zacatl√°n No. 10, Col. San Lorenzo Tezonco, CDMX

¬øDeseas agendar una cita en alguna de nuestras sucursales? (S√≠ / No)

üìå Puedes escribir la palabra *men√∫* para regresar al inicio.""")

        elif contiene(claves_planes, mensaje):
            sesiones[telefono] = {"menu": "planes"}
            return responder(
                "üßæ Has seleccionado *servicios funerarios*. Por favor, elige una opci√≥n:\n"
                "1. Planes de necesidad inmediata\n"
                "2. Planes a futuro\n"
                "3. Servicios individuales\n\n"
                "üìù Escribe el n√∫mero de la opci√≥n deseada.\n"
                "üìå Escribe la palabra *men√∫* para regresar al inicio."
            )
        else:
            # Si el mensaje inicial no coincide con ninguna palabra clave, muestra el men√∫ de bienvenida
            return responder(MENSAJE_BIENVENIDA)

    # ----------------------------- #
    # FLUJO: EMERGENCIA
    # ----------------------------- #
    if sesiones[telefono].get("menu") == "emergencia":
        alerta = f"""üì® *NUEVA EMERGENCIA FUNERARIA*
De: {telefono}
Mensaje: {mensaje}
"""
        requests.post(TWILIO_MESSAGING_URL, auth=TWILIO_AUTH, data={
            "To": NUMERO_REENVIO,
            "From": "whatsapp:+14155238886",
            "Body": alerta
        })
        requests.post(TWILIO_MESSAGING_URL, auth=TWILIO_AUTH, data={
            "To": "+525523680734", # N√∫mero secundario para emergencias
            "From": "whatsapp:+14155238886",
            "Body": alerta
        })

        sesiones[telefono] = {} # Reinicia la sesi√≥n despu√©s de enviar la alerta
        return responder("‚úÖ Gracias. Hemos recibido tu emergencia. Un asesor te contactar√° de inmediato.\n\nüìå Si deseas m√°s informaci√≥n, escribe la palabra *men√∫* para regresar al inicio.")

    # ----------------------------- #
    # FLUJO: UBICACI√ìN
    # ----------------------------- #
    if sesiones[telefono].get("menu") == "ubicacion":
        if mensaje.lower() in ["s√≠", "si", "si me gustar√≠a", "si quiero"]:
            sesiones[telefono]["menu"] = "cita" # Cambia el estado para solicitar datos de cita
            return responder("Perfecto. Por favor, ind√≠canos tu nombre y un horario preferido para la cita.\n\nüìå Escribe la palabra *men√∫* para regresar al inicio.")
        elif mensaje.lower() in ["no", "no gracias", "no por ahora"]:
            sesiones[telefono] = {} # Reinicia la sesi√≥n si no quiere cita
            return responder("‚úÖ Gracias por consultar nuestras ubicaciones. Si necesitas algo m√°s, escribe la palabra *men√∫* para regresar al inicio.")
        else:
            return responder("No entend√≠ tu respuesta. ¬øTe gustar√≠a agendar una cita? Responde 's√≠' o 'no'.\n\nüìå Escribe la palabra *men√∫* para regresar al inicio.")
    
    # ----------------------------- #
    # FLUJO: PLANES
    # ----------------------------- #
    if sesiones[telefono].get("menu") == "planes":
        if "submenu" not in sesiones[telefono]: # Si a√∫n no ha elegido un submen√∫ de planes (1, 2 o 3)
            if mensaje == "1":
                sesiones[telefono]["submenu"] = "inmediato"
                return responder(
                    "‚è±Ô∏è *Planes de necesidad inmediata:*\n"
                    "A. Cr√©dito de necesidad inmediata\n"
                    "B. Servicio paquete fetal cremaci√≥n\n"
                    "C. Servicio paquete sencillo sepultura\n"
                    "D. Servicio paquete b√°sico sepultura\n"
                    "E. Servicio cremaci√≥n directa\n"
                    "F. Servicio paquete de cremaci√≥n\n"
                    "G. Servicio paquete legal\n"
                    "H. Servicio de refrigeraci√≥n y conservaci√≥n\n\n"
                    "üìù Escribe la letra correspondiente para m√°s informaci√≥n.\n"
                    "üîô Escribe *regresar* para volver.\n"
                    "üìå Escribe *men√∫* para regresar al inicio."
                )

            elif mensaje == "2":
                sesiones[telefono]["submenu"] = "futuro"
                return responder(
                    "üï∞Ô∏è *Planes a futuro:*\n"
                    "I. Red Biker\n"
                    "J. Red Plus\n"
                    "K. Red Consorcio\n"
                    "L. Red Adulto Mayor\n"
                    "M. Preventa de Nichos a Temporalidad\n\n"
                    "üìù Escribe la letra correspondiente para m√°s informaci√≥n.\n"
                    "üîô Escribe *regresar* para volver.\n"
                    "üìå Escribe *men√∫* para regresar al inicio."
                )

            elif mensaje == "3":
                sesiones[telefono]["submenu"] = "servicios"
                sesiones[telefono]["menu_serv"] = "categorias" # Establece el estado para la selecci√≥n de categor√≠as de servicios
                return responder(
                    "‚òùüèªÔ∏è *Servicios Individuales* ‚Äì Elige una categor√≠a:\n\n"
                    "A. Tr√°mites y Papeler√≠a\n"
                    "B. Traslados y Carrozas\n"
                    "C. Objetos y Equipamiento\n"
                    "D. Procedimientos Especiales\n\n"
                    "üìù Escribe la letra correspondiente.\n"
                    "üîô Escribe *regresar* para volver.\n"
                    "üìå Escribe *men√∫* para regresar al inicio."
                )

            else:
                return responder("‚ùå Opci√≥n no v√°lida. Escribe 1, 2 o 3.\nüìå Tambi√©n puedes escribir *men√∫* para regresar al inicio.")

        # Si ya est√° en un submen√∫ de planes (inmediato, futuro)
        elif sesiones[telefono]["submenu"] in ["inmediato", "futuro"]:
            letra = mensaje.strip().upper() # Convertir a may√∫sculas para una comparaci√≥n consistente
            if letra in selecciones_letras:
                clave = selecciones_letras[letra]
                respuesta = responder_plan(clave)
                sesiones[telefono] = {} # Reinicia la sesi√≥n despu√©s de dar la informaci√≥n del plan
                return responder(respuesta + "\n\nüìå Si necesitas algo m√°s, escribe la palabra *men√∫* para regresar al inicio.")
            else:
                return responder("‚ùå Letra no reconocida. Intenta otra opci√≥n o escribe *regresar* para volver al submen√∫.\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")

        # Si est√° en el submen√∫ de servicios individuales
        elif sesiones[telefono]["submenu"] == "servicios":
            letra = mensaje.strip().upper()

            if sesiones[telefono]["menu_serv"] == "categorias":
                if letra == "A":
                    sesiones[telefono]["menu_serv"] = "tramites"
                    return responder(
                        "üìú *Tr√°mites y Papeler√≠a:*\n"
                        "Z. Tr√°mites de inhumaci√≥n\n"
                        "AA. Tr√°mites de cremaci√≥n\n"
                        "AB. Tr√°mites legales\n"
                        "AC. Tr√°mites de traslado\n"
                        "AD. Tr√°mites de internaci√≥n nacional\n"
                        "AE. Tr√°mites de internaci√≥n internacional\n\n"
                        "üìù Escribe la letra deseada.\n"
                        "üîô Escribe *regresar* para volver a categor√≠as.\n"
                        "üìå Escribe *men√∫* para volver al inicio."
                    )
                elif letra == "B":
                    sesiones[telefono]["menu_serv"] = "traslados"
                    return responder(
                        "üöö *Traslados y Carrozas:*\n"
                        "N. Traslado\n"
                        "S. Carroza local\n"
                        "T. Carroza a pante√≥n u horno crematorio\n"
                        "U. Carroza legal\n"
                        "V. Cami√≥n local\n"
                        "AJ. Traslado carretero por km\n"
                        "AK. Traslado de terracer√≠a por km\n"
                        "AL. Cami√≥n for√°neo por km\n\n"
                        "üìù Escribe la letra deseada.\n"
                        "üîô Escribe *regresar* para volver a categor√≠as.\n"
                        "üìå Escribe *men√∫* para volver al inicio."
                    )
                elif letra == "C":
                    sesiones[telefono]["menu_serv"] = "equipamiento"
                    return responder(
                        "üõÑ *Objetos y Equipamiento:*\n"
                        "O. Ata√∫d\n"
                        "P. Urna\n"
                        "AF. Equipo de velaci√≥n\n"
                        "AG. Cirios\n"
                        "AH. Capilla de gobierno\n"
                        "AI. Capilla particular\n\n"
                        "üìù Escribe la letra deseada.\n"
                        "üîô Escribe *regresar* para volver a categor√≠as.\n"
                        "üìå Escribe *men√∫* para volver al inicio."
                    )
                elif letra == "D":
                    sesiones[telefono]["menu_serv"] = "procedimientos"
                    return responder(
                        "üß™ *Procedimientos Especiales:*\n"
                        "Q. Velaci√≥n\n"
                        "R. Boletas\n"
                        "W. Embalsamado\n"
                        "X. Embalsamado legal\n"
                        "Y. Embalsamado infecto-contagiosa\n\n"
                        "üìù Escribe la letra deseada.\n"
                        "üîô Escribe *regresar* para volver a categor√≠as.\n"
                        "üìå Escribe *men√∫* para volver al inicio."
                    )
                else:
                    return responder("‚ùå Categor√≠a no reconocida. Escribe A, B, C o D.\nüìå Puedes escribir *men√∫* para volver al inicio.")

            # Si est√° en un sub-submen√∫ de servicios individuales (tr√°mites, traslados, etc.)
            elif sesiones[telefono]["menu_serv"] in ["tramites", "traslados", "equipamiento", "procedimientos"]:
                if letra in selecciones_letras:
                    clave = selecciones_letras[letra]
                    respuesta = responder_plan(clave)
                    sesiones[telefono] = {} # Reinicia la sesi√≥n despu√©s de dar la informaci√≥n del servicio
                    return responder(respuesta + "\n\nüìå Si necesitas algo m√°s, escribe la palabra *men√∫* para regresar al inicio.")
                else:
                    return responder("‚ùå Letra no reconocida. Intenta de nuevo o escribe *regresar* para volver.\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")
    
    # ----------------------------- #
    # FLUJO: CITA DESDE UBICACI√ìN
    # ----------------------------- #
    if sesiones[telefono].get("menu") == "cita":
        datos = f"üìÜ *CITA SOLICITADA*\nCliente: {telefono}\nDatos: {mensaje}"
        requests.post(TWILIO_MESSAGING_URL, auth=TWILIO_AUTH, data={
            "To": NUMERO_REENVIO,
            "From": "whatsapp:+14155238886",
            "Body": datos
        })
        sesiones[telefono] = {} # Reinicia la sesi√≥n despu√©s de registrar la cita
        return responder("‚úÖ Gracias. Hemos registrado tu solicitud de cita. Nuestro equipo te contactar√° pronto.\n\nüìå Puedes escribir la palabra *men√∫* para volver al inicio.")

    # ----------------------------- #
    # RESPUESTA GENERAL SI NADA COINCIDE
    # ----------------------------- #
    # Si el mensaje no fue manejado por ning√∫n estado espec√≠fico, o si el estado es inv√°lido,
    # se devuelve al men√∫ principal. Esto act√∫a como un "catch-all" para entradas inesperadas.
    return responder("ü§ñ No entendimos tu mensaje. Puedes escribir la palabra *men√∫* para comenzar o intentar con otra opci√≥n v√°lida.")

# ----------------------------- #
# INICIO DEL SERVIDOR
# ----------------------------- #
if __name__ == "__main__":
    app.run(debug=True)
    
if __name__ == "__main__":
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))
